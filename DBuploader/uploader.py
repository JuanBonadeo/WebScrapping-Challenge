import psycopg2
import csv
from typing import Optional
from datetime import datetime

def create_schemas(connection):
    with connection.cursor() as cur:
        # Borrar tablas si existen
        cur.execute("""
        DROP TABLE IF EXISTS item_price CASCADE;
        DROP TABLE IF EXISTS product CASCADE;
        DROP TABLE IF EXISTS category CASCADE;
        DROP TABLE IF EXISTS store CASCADE;
        DROP TABLE IF EXISTS brand CASCADE;
        """)
        connection.commit()
        
        # Tabla brand
        cur.execute("""
        CREATE TABLE IF NOT EXISTS brand (
            brand_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            brand_name VARCHAR(255)
        )
        """)
            
        # Tabla store
        cur.execute("""
        CREATE TABLE IF NOT EXISTS store (
            store_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            brand_id INTEGER REFERENCES brand(brand_id),
            internal_id VARCHAR(50),
            address VARCHAR(255),
            city VARCHAR(100),
            state VARCHAR(2),
            latitude DECIMAL(10, 7),
            longitude DECIMAL(10, 7)
        )
        """)
        
        # Tabla category 
        cur.execute("""
        CREATE TABLE IF NOT EXISTS category (
            category_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            brand_id INTEGER REFERENCES brand(brand_id),
            internal_id VARCHAR(50),
            category_name VARCHAR(255),
            total_products INTEGER
        )
        """)
        
        # Tabla product
        cur.execute("""
        CREATE TABLE IF NOT EXISTS product (
            product_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            category_id INTEGER NOT NULL REFERENCES category(category_id),  
            internal_id VARCHAR(50),
            product_name VARCHAR(255),
            upc VARCHAR(20),
            size VARCHAR(50),
            brand VARCHAR(100),
            weight VARCHAR(100),
            height VARCHAR(100),
            width VARCHAR(100),
            length VARCHAR(100),
            color VARCHAR(100)
        )
        """)
        
        # Tabla item_price
        cur.execute("""
        CREATE TABLE IF NOT EXISTS item_price (
            item_price_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            product_id INTEGER REFERENCES product(product_id),
            store_id INTEGER REFERENCES store(store_id),  
            status VARCHAR(20),
            unit_price DECIMAL(10, 2),
            sale_price DECIMAL(10, 2),
            list_price DECIMAL(10, 2),
            created_at TIMESTAMP
        )
        """)
            
        connection.commit()

   
def build_category_mapping(connection, brand_id):
    with connection.cursor() as cur:
        cur.execute("""
        SELECT internal_id, category_id FROM category WHERE brand_id = %s
        """, (brand_id,))
        return {row[0]: row[1] for row in cur.fetchall()}


def build_store_mapping(connection, brand_id):
    with connection.cursor() as cur:
        cur.execute("""
        SELECT internal_id, store_id FROM store WHERE brand_id = %s
        """, (brand_id,))
        return {row[0]: row[1] for row in cur.fetchall()}

  
def build_product_mapping(connection, brand_id):
    with connection.cursor() as cur:
        cur.execute("""
        SELECT p.internal_id, p.product_id
        FROM product p
        JOIN category c ON p.category_id = c.category_id
        WHERE c.brand_id = %s
        """, (brand_id,))
        return {row[0]: row[1] for row in cur.fetchall()}


def get_or_create_brand(connection, brand_name: str) -> Optional[int]:
    try:
        with connection.cursor() as cur:
            # Verificar si la marca ya existe
            cur.execute("""
            SELECT brand_id FROM brand WHERE brand_name = %s
            """, (brand_name,))
            
            result = cur.fetchone()
            
            if result:
                return result[0] 
            
            # Crear nueva marca si no existe
            cur.execute("""
            INSERT INTO brand (brand_name)
            VALUES (%s)
            RETURNING brand_id
            """, (brand_name,))
            
            brand_id = cur.fetchone()[0]
            connection.commit()
            return brand_id
            
    except psycopg2.Error as e:
        connection.rollback()
        print(f"Error al obtener/crear marca: {e}")
        return None

def import_stores_from_csv(connection, file_path: str, brand_id: int):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)  
            
            with connection.cursor() as cur:
                for row in reader:
                    cur.execute("""
                    INSERT INTO store (brand_id, internal_id, address, city, state, latitude, longitude)
                    VALUES (%(brand_id)s, %(internal_id)s, %(address)s,%(city)s, %(state)s,%(latitude)s, %(longitude)s)
                    """, {
                        'brand_id': brand_id,
                        'internal_id': row.get('internal_id'),
                        'address': row.get('address'),
                        'city': row.get('city'),
                        'state': row.get('state'),
                        'latitude': float(row.get('latitude', 0)),
                        'longitude': float(row.get('longitude', 0))
                    })
                
                connection.commit()
                print(f"✅ {reader.line_num - 1} tiendas importadas para la marca ID {brand_id}")
                
    except Exception as e:
        connection.rollback()
        print(f"❌ Error al importar tiendas: {e}")

def import_categories_from_csv(connection, file_path: str, brand_id: int):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            with connection.cursor() as cur:
                for row in reader:
                    cur.execute("""
                    INSERT INTO category (
                        brand_id, internal_id, 
                        category_name, total_products
                    )
                    VALUES (
                        %(brand_id)s, %(internal_id)s, 
                        %(category_name)s, %(total_products)s
                    )
                    RETURNING category_id
                    """, {
                        'brand_id': brand_id,
                        'internal_id': row.get('internal_id'),
                        'category_name': row.get('category_name'),
                        'total_products': int(row.get('total_products', 0))
                    })
                
                connection.commit()
                print(f"✅ {reader.line_num - 1} categorias importadas para la marca ID {brand_id}")
    except Exception as e:
        connection.rollback()
        print(f"❌ Error al importar categorías: {e}")

def get_category_id(connection, brand_id: int, internal_id: str) -> Optional[int]:
    try:
        with connection.cursor() as cur:
            cur.execute("""
                SELECT category_id FROM category
                WHERE brand_id = %s AND internal_id = %s
            """, (brand_id, internal_id))
            
            result = cur.fetchone()
            if result:
                return result[0]
            else:
                print(f"⚠️ Categoría con internal_id '{internal_id}' no encontrada para brand_id {brand_id}")
                return None
    except Exception as e:
        print(f"❌ Error al obtener categoría: {e}")
        return None

def import_products_from_csv(connection, file_path: str, brand_id: int):
    try:
        category_map = build_category_mapping(connection, brand_id)

        with open(file_path , 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            with connection.cursor() as cur:
                for row in reader:
                    internal_cat_id = row.get('internal_category_id')
                    if internal_cat_id.startswith('[') and internal_cat_id.endswith(']'):
                        internal_cat_id = internal_cat_id[2:-2]  # eliminar los corchetes y ''
                    if internal_cat_id.startswith('/'):
                        internal_cat_id = internal_cat_id[1:]  # eliminar el primer carácter
                    category_id = category_map.get(internal_cat_id)

                    if category_id is None:
                        continue

                    cur.execute("""
                    INSERT INTO product (
                         category_id, internal_id, 
                        product_name, upc, size, brand, 
                        weight, height, width, length, color
                    )
                    VALUES (
                         %(category_id)s, %(internal_id)s,
                        %(product_name)s, %(upc)s, %(size)s, %(brand)s,
                        %(weight)s, %(height)s, %(width)s, %(length)s, %(color)s
                    )
                    """, {
                        'category_id': category_id,
                        'internal_id': row.get('internal_id'),
                        'product_name': row.get('name'),
                        'upc': row.get('upc'),
                        'size': row.get('size'),
                        'brand': row.get('brand'),
                        'weight': row.get('weight') ,
                        'height': row.get('height') ,
                        'width': row.get('width') ,
                        'length': row.get('length') ,
                        'color': row.get('color')
                    })

                connection.commit()
                print(f"✅ {reader.line_num - 1} productos importados para la marca ID {brand_id}")
    except Exception as e:
        connection.rollback()
        print(f"❌ Error al importar productos: {e}")




def main(brand_name: str ):
    try:
        conn = psycopg2.connect(
            dbname="postgres",
            user="postgres",
            password="123456",
            host="localhost",
            port="5432"
        )
        # 1. Verificar conexión
        if conn.closed:
            raise Exception("No se pudo conectar a la base de datos")
        print("✅ Conexión a la base de datos exitosa")
        
        
        
        # 2. Obtener o crear la marca 
        brand_id = get_or_create_brand(conn, brand_name)
        
        if not brand_id:
            raise Exception("No se pudo obtener/crear la marca Sedanos")
        
        print(f"✅ Marca {brand_name} con ID: {brand_id}")
        
        # 3. Importar tiendas asociadas a esta marca
        import_stores_from_csv(conn, f'./data/{brand_name}_stores.csv', brand_id)
        
        # 4. Importar categorías asociadas a esta marca
        import_categories_from_csv(conn, f'./data/{brand_name}_all_categories.csv', brand_id)
        
        # 5. Importar productos asociados a esta marca
        import_products_from_csv(conn, f'./data/{brand_name}_products.csv', brand_id)
        
    except Exception as e:
        print(f"❌ Error en el proceso principal: {e}")
    finally:
        if 'conn' in locals() and conn:
            conn.close()
            print("✅ Conexión cerrada")





# conn = psycopg2.connect(
#             dbname="postgres",
#             user="postgres",
#             password="123456",
#             host="localhost",
#             port="5432"
#         )
# create_schemas(conn)
# main(brand_name="sedanos")
# main(brand_name="cotsco")






            
def prices(brand_name: str):
    try:
        conn = psycopg2.connect(
            dbname="postgres",
            user="postgres",
            password="123456",
            host="localhost",
            port="5432"
        )

        if conn.closed:
            raise Exception("No se pudo conectar a la base de datos")
        print("✅ Conexión a la base de datos exitosa")

        
        brand_id = get_or_create_brand(conn, brand_name)
        print(f"✅ Marca '{brand_name}' con ID: {brand_id}")

       
        file_path = f'./data/{brand_name}_item_prices_15_05.csv'

        # Cargar mapas
        store_map = build_store_mapping(conn, brand_id)
        product_map = build_product_mapping(conn, brand_id)

        not_found_count = 0
        total_imported = 0

        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            with conn.cursor() as cur:
                for row in reader:
                    store_id = store_map.get(row.get('store_id'))
                    product_id = product_map.get(row.get('product_id'))

                    if store_id is None or product_id is None:
                        not_found_count += 1
                        continue

                
                    created_at_raw = row.get('date')
                    try:
                        created_at = datetime.fromisoformat(created_at_raw) if created_at_raw else None
                    except ValueError:
                        created_at = None  

                    cur.execute("""
                        INSERT INTO item_price (
                            product_id, store_id, status, 
                            unit_price, sale_price, list_price, created_at
                        )
                        VALUES (
                            %(product_id)s, %(store_id)s, %(status)s,
                            %(unit_price)s, %(sale_price)s, %(list_price)s, %(created_at)s
                        )
                    """, {
                        'product_id': product_id,
                        'store_id': store_id,
                        'status': row.get('status'),
                        'unit_price': float(row.get('unit_price') or 0),
                        'sale_price': float(row.get('sale_price') or 0),
                        'list_price': float(row.get('list_price') or 0),
                        'created_at': created_at
                    })
                    total_imported += 1

                conn.commit()

        print(f"✅ {total_imported} precios importados correctamente para '{brand_name}' (ID: {brand_id})")
        if not_found_count > 0:
            print(f"⚠️ {not_found_count} filas omitidas por no encontrar store_id o product_id en los mapas.")

    except Exception as e:
        print(f"❌ Error en el proceso de importación de precios: {e}")
    finally:
        if 'conn' in locals() and conn:
            conn.close()
            print("✅ Conexión cerrada")

prices(brand_name='sedanos')

prices(brand_name='cotsco')